{-# language FlexibleInstances #-}
{-# language RankNTypes #-}

module Teacher
    ( module Teachers.Teacher
    , teacherWithTarget
    , teacherWithTargetNonDet
    , teacherWithIO
    , teacherWithIO2
    , teacherWithTargetAndIO
    ) where

import Teachers.Teacher
import Teachers.Terminal
import Teachers.Whitebox

import Data.IORef
import System.IO.Unsafe (unsafePerformIO)

import NLambda hiding (alphabet)
import qualified NLambda (alphabet)
import Prelude hiding (map)

-- We provide three ways to construct teachers:
-- 1. Fully automatic
-- 2. Fully interactive (via IO)
-- 3. Automatic membership, but interactive equivalence tests
-- Furthermore we provide a teacher which counts and then passes the query
-- to a delegate.

-- 1. This is a fully automatic teacher, which has an internal automaton
-- Only works for DFAs for now, as those can be checked for equivalence
teacherWithTarget :: (Show i, Show q, Nominal i, Nominal q, Contextual i) => Automaton q i -> Teacher i
teacherWithTarget aut = Teacher
    { membership = cacheOracle (isTrue . accepts aut)
    , equivalent = eqGeneraliser consts (isTrue . accepts aut) (automaticEquivalent bisim aut)
    , alphabet   = NLambda.alphabet aut
    , constants  = consts
    }
    where consts = unsafePerformIO $ newIORef []

-- 1b. This is a fully automatic teacher, which has an internal automaton
-- NFA have undecidable equivalence, n is a bound on deoth of bisimulation.
teacherWithTargetNonDet :: (Show i, Show q, Nominal i, Nominal q, Contextual i) => Int -> Automaton q i -> Teacher i
teacherWithTargetNonDet n aut = Teacher
    { membership = cacheOracle (isTrue . accepts aut)
    , equivalent = eqGeneraliser consts (isTrue . accepts aut) (automaticEquivalent (bisimNonDet n) aut)
    , alphabet   = NLambda.alphabet aut
    , constants  = consts
    }
    where consts = unsafePerformIO $ newIORef []

-- 2. Will ask everything to someone reading the terminal
-- For the moment only Atom as input type
-- Note that parsing is very unforgiving, one mistake, and there is no way back
-- Atoms are referenced by Ints. When the user provides a counter example, we
-- consider the whole orbit generated by it.
teacherWithIO :: (Show i, Read i, Nominal i, Contextual i) => Set i -> Teacher i
teacherWithIO alph = Teacher
    { membership = cacheOracle ioMembership
    , equivalent = eqGeneraliser consts ioMembership ioEquivalent
    , alphabet   = alph
    , constants  = consts
    }
    where
        consts = unsafePerformIO $ newIORef []

-- 2b. Same as above. But with machine readable queries (except for EQs maybe)
teacherWithIO2 :: (Show i, Read i, Nominal i, Contextual i) => Set i -> Teacher i
teacherWithIO2 alph = Teacher
    { membership = cacheOracle ioMembership2
    , equivalent = eqGeneraliser consts ioMembership2 ioEquivalent2
    , alphabet   = alph
    , constants  = consts
    }
    where consts = unsafePerformIO $ newIORef []

-- 3. A teacher uses a target for the mebership queries, but you for equivalence
-- Useful as long as you don't have an equivalence check
-- used for NFAs when there was no bounded bisimulation yet
teacherWithTargetAndIO :: (Show i, Show q, Read i, Nominal i, Contextual i, Nominal q) => Automaton q i -> Teacher i
teacherWithTargetAndIO aut = Teacher
    { membership = cacheOracle (isTrue . accepts aut)
    , equivalent = eqGeneraliser consts (isTrue . accepts aut) ioEquivalent
    , alphabet   = NLambda.alphabet aut
    , constants  = consts
    }
    where consts = unsafePerformIO $ newIORef []

automaticEquivalent :: (Nominal a, Contextual a) => (p1 -> p2 -> Set a) -> p1 -> p2 -> Maybe a
automaticEquivalent bisimlator aut hypo = case solve isEq of
        Nothing    -> error "should be solved"
        Just True  -> Nothing
        Just False -> Just (head . toList . mapFilter id . setOrbitsRepresentatives $ bisimRes)
        where
            bisimRes = bisimlator aut hypo
            isEq = isEmpty bisimRes
